<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Micah Roberson]]></title>
  <link href="http://micahroberson.github.com/atom.xml" rel="self"/>
  <link href="http://micahroberson.github.com/"/>
  <updated>2013-08-17T11:52:58-07:00</updated>
  <id>http://micahroberson.github.com/</id>
  <author>
    <name><![CDATA[Micah Roberson]]></name>
    <email><![CDATA[micah.roberson@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Preventing Duplicate Content | Rails SEO Tip]]></title>
    <link href="http://micahroberson.github.com/prevent_duplicate_content/"/>
    <updated>2013-08-17T11:13:00-07:00</updated>
    <id>http://micahroberson.github.com/prevent_duplicate_content</id>
    <content type="html"><![CDATA[<p>It&#8217;s useful to allow users to reach your site by visiting both the naked domain, greeksquare.com, as well as the www. prefixed version, www.greeksquare.com. However, this puts search engines in a sticky situation because from their perspective, these are two different sites with the same exact content. Fortunately, there&#8217;s a simple solution for site&#8217;s built with any Rack based web server(ie. Ruby on Rails, Sinatra, etc.): <a href="https://github.com/jtrupiano/rack-rewrite">rack-rewrite</a>. Rack-rewrite is a simple middleware for applying rewrite rules (redirects) and we&#8217;re going to use it to redirect a couple of prefixed domains to the naked domain. By pointing all variations of the same content to one place, we eliminate the competition between the different URLs, and also boost the overall relevancy and popularity.</p>

<p>For this example, I&#8217;m going to use some snippets from the main Rails app behind <a href="https://greeksquare.com">GreekSquare</a>. Let&#8217;s begin by adding the rack-rewrite gem:</p>

<pre><code>gem 'rack-rewrite'
</code></pre>

<p>Once the gem is installed, its as simple as adding some rules to production.rb. If you plan on having several rules, it would be best to put this in an initializer.</p>

<pre><code>config.middleware.insert_before(Rack::Lock, Rack::Rewrite) do
  r301 %r{.*}, 'http://greeksquare.com$&amp;', :if =&gt; Proc.new {|rack_env|
    rack_env['SERVER_NAME'] == 'www.greeksquare.com' || rack_env['SERVER_NAME'].include?('herokuapp')
  }
end
</code></pre>

<p>In this example I&#8217;m rewriting all &#8216;www.greeksquare.com&#8217; and &#8216;greeksquare.herokuapp.com&#8217; requests to simply be the naked domain &#8216;greeksquare.com&#8217;.  Also notice the redirect status code being used, r301, which indicates the site has &#8216;Moved Permanently&#8217;. More info on status codes <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">here</a>.</p>

<p>It&#8217;s also a good idea to make sure you set the Preferred domain in Google&#8217;s Webmaster Tools. It&#8217;s easy to get setup with Webmaster Tools, and once you do just visit the Site Settings page where you&#8217;ll find the form below:</p>

<p><img class="center" src="http://micahroberson.github.com/images/preferred_url.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why You Need a Red Team]]></title>
    <link href="http://micahroberson.github.com/why-you-need-a-red-team/"/>
    <updated>2013-08-14T08:47:00-07:00</updated>
    <id>http://micahroberson.github.com/why-you-need-a-red-team</id>
    <content type="html"><![CDATA[<p>A couple of weeks ago, an episode of HBO&#8217;s <em>The Newsroom</em> brought to light the concept and importance of having a &#8216;red team&#8217;. The red team, as described in the show, is a select group of team members who are intentionally left in the dark while a story is flushed out. Once enough &#8216;proof&#8217; has been established by the reporters chasing the story, they would then run it by the red team to see if the fresh eyes can poke any holes in it.</p>

<p>The concept certainly isn&#8217;t new and you probably use it already, but perhaps not as often as you should. Its especially valuable to have a fresh perspective on a website you&#8217;ve been heads-down on for the past month before releasing for the client. It&#8217;s not uncommon for the seemingly miniscule assumptions you started the project with, to grow into some pretty large and unpredicted changes by the end, so it&#8217;s important to make sure the team made the right decisions along the way. The best way to do this is to show a team member the dev site and see if they can identify how all of the requirements have been met.</p>

<p>Any process where someone&#8217;s work is reviewed by another team member is similar to a red team scenario, but there&#8217;s one major difference: the reviewer is oftentimes not looking for reasons the work is poor, but rather reasons said work is good or OK. With this comes differing levels of scrutiny, and resultantly not all of the same problems will be identified by the more positive reviewer as those identified by the more negative reviewer. Use your best judgement to determine if a scenario requires the use of a red team, but most situations where the main team has any doubt or made several assumptions are generally good candidates and will see the most benefit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Absolute Links with Backbone.js and Rails]]></title>
    <link href="http://micahroberson.github.com/absolute-links-with-backbone-dot-js-and-rails/"/>
    <updated>2013-07-18T09:15:00-07:00</updated>
    <id>http://micahroberson.github.com/absolute-links-with-backbone-dot-js-and-rails</id>
    <content type="html"><![CDATA[<p>Ideally user&#8217;s won&#8217;t ever need to refresh your single page app. With the use of websockets, or simulated websockets via polling, this is avoidable nearly 100% of the time. However, there are some cases where it would be very handy for the user to be able to refresh the page and return to exactly where they were. Perhaps the most important scenario is actually for developers! Making a code change and having to click through several links to actually test the code leaves something to be desired.</p>

<p>To start we need to make sure all Backbone URL/non-API requests get routed to load up the app appropriately. From Rails&#8217; perspective, its rendering the same view, home#index, for every non-API request but making sure the relative path gets passed along with it. To keep it simple, I&#8217;ve just added a catch-all route, but it may be better to whitelist specific routes that match up with your Backbone.js routes. Notice I&#8217;m using Devise and also include some &#8220;api&#8221; scoped routes to illustrate how this particular app is setup.</p>

<pre><code>devise_for :users
scope :path =&gt; "api" do
  resources :projects
  ...
  resources :posts
end
constraints :format =&gt; "html" do
  match '*path', :controller =&gt; 'home', :action =&gt; 'index'
end
</code></pre>

<p>Within the Home Index view, we just need to ensure we pass down that params[:path] value to the backbone router. This is a snippet from index.html.erb and also where I would include any bootstrapped data that the app would always need before starting up.</p>

<pre><code>&lt;script&gt;
  require([
    'jquery',
    'underscore',
    'backbone',
    'router'
  ], function($, _, Backbone, Router){
    $(function() {
      // Set the current user
      currentUserModel.set(#{Rabl::Renderer.new('users/current_user', current_user, :view_path =&gt; 'app/views').render});
      // Navigate to the current route. One could also pull this from window.location.pathname if no fancy Rails manipulation is req'd
      Router.navigate('&lt;%= params[:path].html_safe %&gt;', {trigger: true});
    });
  });
&lt;/script&gt;
</code></pre>

<p>Assuming all the backbone routes are implemented and setup correctly, this is all that needs to be done! Depending on the type of view, it may need some additional logic to work properly from both an absolute url and also from a relative link within the app. The difference being that it may be dependent on resources being previously loaded which won&#8217;t be available should the user arrive at the view from an absolute path. There&#8217;s a couple of options for this scenario: a. Use a Railsy strategy in the router and run a before_filter on every route to load necessary dependencies before even getting to the view code, b. Pass the model to the view if its available and don&#8217;t if its not, but equip the view to react accordingly. For the former, there&#8217;s a handy Backbone.js mixin called <a href="https://github.com/boazsender/backbone.routefilter">backbone.routefilter</a>, which will call router.before and/or router.after around each route.</p>

<pre><code>before: () -&gt;
  route = Backbone.history.fragment

  if route.indexOf('dashboard') != -1 || route.indexOf('posts') != -1
    if undefined == currentUserModel || currentUserModel.isNew()
      @listenToOnce currentUserModel, 'change', () =&gt; Backbone.history.loadUrl(route)
      return false
</code></pre>

<p>This before filter simply checks for the currentUserModel to be set and returns false if it isn&#8217;t while setting up a callback to re-run the same route once the model IS loaded.  The former solution mentioned above might look like this:</p>

<pre><code>render: () -&gt;
  if !@model
    @model = new userModel _id: @user_id
    @listenToOnce @model, 'sync', @renderProfile
    @model.fetch null, { success: () =&gt; @listenTo @model, 'change', @renderProfile }
    usersCollection.add @model
  else
    @listenTo @model, 'change', @renderProfile
    @renderProfile()

  @$el.html _.template(profileTemplate)
  @
</code></pre>

<p>Depending on the app and if there are some common dependencies throughout, the before filter method might work well, while the latter method might work better for other scenarios. Personally I&#8217;ve used the latter for views that are normally accessed via a list view, ie. a user profile page or detail view, but should still be accessible via the absolute url.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Schema Design]]></title>
    <link href="http://micahroberson.github.com/rails-mongodb-and-embedded-docs/"/>
    <updated>2013-05-12T08:01:00-07:00</updated>
    <id>http://micahroberson.github.com/rails-mongodb-and-embedded-docs</id>
    <content type="html"><![CDATA[<p>I&#8217;m a big fan of MongoDB. I understand that it&#8217;s not great for every dataset out there, nor would I attempt to make it work with a highly relational dataset just because its shiny and new. What I do find rather appealing about MongoDB is the non-rigid document schema and the different mindset you have to have while developing. The non-rigid schema is important because it allows for very agile development and fast iterations. This doesn&#8217;t mean I condone adding and removing fields like crazy. I think I still make pretty calculated decisions when it comes to adding new fields to a collection just because I&#8217;ve been in the RDBMS world for so long - which is a good thing!</p>

<p>The different mindset I mentioned, came about as a result of a conversation I had at <a href="http://www.10gen.com/events/mongodb-san-francisco-2013">MongoDB Days SF</a>. One of the presenters made a point about modeling the data in the database in the same way as you display it in the app. This is a completely different approach than one would take with a classic RDBMS backed application. With an RDBMS, you&#8217;re most likely going to attempt to normalize the entire schema and then potentially denormalize certain fields out on a case-by-case basis. We do all of this with the assumption that normalization is ideal, and redundancy is bad. I think this allusion comes from two things: a. storage space actually used to be an issue due to hardware constraints and thusly cost. and b. you can relatively easily access any piece of data with the use of joins and/or a number of other techniques in an RDBMS. With MongoDB, I&#8217;ll layout the design of a particular view and decide what the main domain model is, and if the view is going to be a list format, there&#8217;s probably some additional metadata from another model that needs to be displayed alongside(i.e. a list of comments, each showing the author thumnail picture and name). At this point, you need to denormalize that metadata in order to avoid the N+1 beast. Although denormalization is necessary for efficient queries, its not all that difficult to maintain nor is it a downside. I much prefer the overall approach to app development with MongoDB and find it much easier to relate the inner-workings to the UI.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Foundation Nav w/ jPanelMenu]]></title>
    <link href="http://micahroberson.github.com/foundation-nav-w-jpanelmenu/"/>
    <updated>2013-05-04T10:21:00-07:00</updated>
    <id>http://micahroberson.github.com/foundation-nav-w-jpanelmenu</id>
    <content type="html"><![CDATA[<p><a href="http://foundation.zurb.com/">Foundation</a> provides some excellent out-of-the-box support for responsive layouts and navigation. However, in building out the new mobile interface for <a href="http://www.greeksquare.com/">GreekSquare</a>, we weren&#8217;t satisfied with the default style.</p>

<p><img class="width-50 right" src="http://micahroberson.github.com//s3.amazonaws.com/micahroberson/greeksquare-mobile-expanded.png"></p>

<p>This isn&#8217;t horrible but it also isn&#8217;t great. I strongly believe a great ui is extremely important and provides for a ton of value to the end-user - especially in the market we&#8217;re going after. I set out to find a suitable javascript implementation of a mobile navigation similar to the Facebook mobile app. I tried several different jquery plugins, but they were all extremely invasive and resulted in messy code with clunky javascript animations that didn&#8217;t fare too well when I tested on an actual device. Finally I came across <a href="http://jpanelmenu.com/">jPanelMenu</a>. jPanelMenu is a lightweight(10kb minified) jquery plugin that lets you pass it any navigation element and flips it around to display in a Facebook style sidenav menu.</p>

<p><img class="width-50 left" src="http://micahroberson.github.com//s3.amazonaws.com/micahroberson/greeksquare-mobile-new-expanded.png"></p>

<p>Much, much better than before - both aesthetically, and from a usability standpoint. The end product came out with very few html changes to existing navbar. I ran into a small hiccup when using the fixed implementation of Foundation&#8217;s navbar, but that was solved by add the following css to shrink it at the same rate as the jPanelMenu expands (ease-in-out at 300ms in my case).</p>

<pre><code>[data-menu-position="open"] .container .fixed {
  left: 200px;
}

.container header .fixed {
  @include transition(ease-in-out left .3s);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone Collections and Foreign Keys]]></title>
    <link href="http://micahroberson.github.com/backbone-collections-and-foreign-keys/"/>
    <updated>2013-05-02T08:16:00-07:00</updated>
    <id>http://micahroberson.github.com/backbone-collections-and-foreign-keys</id>
    <content type="html"><![CDATA[<p>At Arkad, we had the concept of a DataSeries, which was a model that sat at the crossroads of multiple many-to-many relations. Fortunately, we were able to get around modeling ALL of the relations client-side by denormalizing the necessary attributes into the DataSeries json via RABL templates. However, certain client-side foreign key lookups were unavoidable. My first iteration simply used the proxied underscore &#8216;filter&#8217;, &#8216;find&#8217; and &#8216;where&#8217; methods to do the necessary lookups.</p>

<pre><code>getByMappingIdAndCompanyId: function(mapping_id, company_id) {
  var mapping = mappingsCollection.get(mapping_id);
  return _.filter(mapping.get('data_series'), function(ds) {
    var dataSeries = dataSeriesCollection.get(ds.id);
    return (dataSeries !== undefined &amp;&amp; dataSeries.get('company_id') === company_id);
  }, this);
}
</code></pre>

<p>The code above worked, but it was horribly inefficient. In order to find a DataSeries by a mapping_id and company_id, you had to first find the mapping and then look through all the DataSeries it was associated with to find the one with the right company_id. Just so we&#8217;re all on the same page the associations looked like this:</p>

<pre><code>DataSeries
  belongs_to :company
  has_many :mappings

Mapping
  belongs_to :company
  has_many :data_series

Company
  has_many :data_series
  has_many :mappings
</code></pre>

<p>For the next iteration, I modified the RABL file to include mapping_ids in the DataSeries models, and data_series_ids in the Mapping models. Client-side I hashed the models at creation via &#8216;add&#8217;, &#8216;remove&#8217;, &#8216;reset&#8217; events on the collection.</p>

<pre><code>_hashModel: function(model) {
  _.each(model.get('mapping_ids'), function(id) {
    if(!_.has(this._mappingMap, id))
      this._mappingMap[id] = {};
    this._mappingMap[id][model.get('company_id')] = model;
  }, this);

  if(!_.has(this._companyMap, model.get('company_id')))
    this._companyMap[model.get('company_id')] = {};
  this._companyMap[model.get('company_id')][model.id] = model;
},
</code></pre>

<p>There was two main scenarios for accessing the models: by both mapping_id and company_id, and just by company_id. So I created a hash to handle each case, in order to keep the lookup time constant. Although this pseudo-map isn&#8217;t nearly the same as a GLib hash table or STL Map, it&#8217;s safe to assume that lookups are O(1). If you&#8217;re going to be doing more lookups than hashing(adding keys is slow), its safe to use these techniques and worth the additional overhead to hold the &#8216;map&#8217; in memory.</p>

<p>More recently, I&#8217;ve come across a similar scenario that involved model lookup by slug rather than id. MongoDB provides some unsightly ID&#8217;s so I employed the <a href="https://github.com/digitalplaywright/mongoid-slug">mongoid_slug</a> gem to handle slugging on the model&#8217;s name attribute. Mongoid-slug provides an overridden &#8216;find&#8217; method on the model, but using Backbone with a Single Page App, meant I could either always force a model lookup to the backend, or check the client-side collection first(ideal). However, due to the large number of models potentially present client-side, I wanted to avoid a call to _.find for a matching name attribute. Here&#8217;s the extended BaseCollection my collection extends https://gist.github.com/micahroberson/5493159</p>

<pre><code>define [
  'jquery', 'jqueryui', 'underscore', 'backbone'
], 
($, jqueryui, _, Backbone) -&gt;

  class BaseCollection extends Backbone.Collection

    initialize: () -&gt;
      @bindHashEvents()

    # e.g.
    # hash_keys: [
    #   'subject',
    #   'message',
    #   'buildSlug' # where buildSlug: () -&gt; "#{@get('name').downcase().replace(/\s/g,'-')}"
    # ]
    hash_keys: []

    # key is the attribute originally set via hash_keys(e.g. 'name'), lookup_val is the search term (e.g. 'Frank')
    retrieveFromHash: (key, lookup_val) -&gt;
      if !key then return []

      @["_#{key}_hash"][lookup_val]

    bindHashEvents: (hash_keys) -&gt;
      # Check for hash keys a la delegateEvents paradigm
      if !(hash_keys || (hash_keys = _.result(this, 'hash_keys'))) then return @

      _.each hash_keys, (key) =&gt;
        # initialize hash
        @["_#{key}_hash"] = {}

        hashSingle = (model) =&gt;
          # first check if key is method defined on the model, otherwise assume its an attribute on model
          hk = if typeof model[key] == 'function' then model[key]() else model.get(key)
          @["_#{key}_hash"][hk] = model unless !hk

        @listenTo @, 'add', hashSingle

        @listenTo @, 'reset', (collection) =&gt;
          @["_#{key}_hash"] = {}
          _.each(@models, hashSingle, @)

        @listenTo @, 'remove', (model) =&gt;
          hk = if typeof model[key] == 'function' then model[key]() else model.get(key)
          delete @["_#{key}_hash"][hk]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Not Another Productivity Post]]></title>
    <link href="http://micahroberson.github.com/not-another-productivity-post/"/>
    <updated>2012-12-01T13:21:00-08:00</updated>
    <id>http://micahroberson.github.com/not-another-productivity-post</id>
    <content type="html"><![CDATA[<p>Note: This is not a bunch of tips on how to block Facebook or why you should be setting timers to keep yourself focused. Its merely a series of observations and hypotheses I made over the course of several client-projects at ReadyApps.</p>

<p>Our very first client came back for additional projects a number of times. While working on the most recent of these, James pointed out that we are always much more efficient when working on projects for this client than anything else. I gave it some thought, and came up with a few main reasons:</p>

<ol>
<li><p>The scope is always small and well defined. Sometimes its a series of small updates, sometimes its a whole new feature that requires end-to-end code changes, but its always well thought out. This client knows, for the most part, exactly what they want added and/or changed and how they would like it to function. And if they don&#8217;t have it down pat, we clear it up in the meeting beforehand. This one can&#8217;t always be replicated, because oftentimes the client doesn&#8217;t know what they want. However, that just means we&#8217;re required to take upon that role and set the requirements and guidelines for ourselves.</p></li>
<li><p>We know the codebase inside and out. We spent how many months on that first iteration? This may have been the first project we ever did and it may not be quite up to par with our latest endeavors(we tend to stay away from ASP.NET these days), but we still know whats going on and how to add new features. Part of the reason is that we started with a very simple concept and continuously built on top of it. With each iteration we were doing pretty much the same thing. Add an ASP gridview , make a few database changes, bind the table with a SQL datasource, etc. This repetition and constant contact with the codebase is what established our familiarity.</p></li>
<li><p>We make sure we work on it together. This one&#8217;s big. And we&#8217;ve know this for a while, but this project is still the only one we do it on. We hate the thought of working on that codebase, so we go in with the intention of banding together and getting shit done. And its never as bad as it seems, its just not as fun as working on something newer(and not ASP.NET). Its like going to the gym - you can get a decent workout going by yourself, but you&#8217;re never going to be able to push yourself like you can with someone spotting you and trying to out-benchpress you.</p></li>
<li><p>&#8216;With the intention of getting shit done&#8217;. This is another tremendously important factor in the productivity equation. There&#8217;s big difference between starting a project with the mindset of <i>just casually going at it with no real direction</i> vs. <i>taking calculated steps to hit all of the requirements and ship something</i>. The latter results in a productivity increase of 1000x (I ran the numbers&#8230;). We shouldn&#8217;t start coding up a feature until we have some direction and we also shouldn&#8217;t quit working on a feature until its done and functioning. This doesn&#8217;t mean we don&#8217;t switch projects, it means within a single project, we should start a feature and make sure its done and ready to ship before moving on. This can be applied all sorts of tasks, not just coding.</p></li>
</ol>


<p>So what do we take away from all of this? Two things. The fact that we are most efficient on this one specific codebase is just wrong. It&#8217;s actually ridiculous. We definitely don&#8217;t know the ASP.NET more than PHP or Ruby, and it definitely doesn&#8217;t offer up much in regards to &#8216;rapid prototyping&#8217;. Its purely how we work on the projects and the mindset we go in with. Second thing. Make sure the feature-sets are well defined, and there&#8217;s never a single developer completing the entire project.</p>
]]></content>
  </entry>
  
</feed>
